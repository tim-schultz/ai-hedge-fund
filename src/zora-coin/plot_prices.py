"""Plot price‑time series for each pool using cached slot0 data.

Assumes the wide‑format parquet generated by swap_data.py:
    index : block_number  (int)
    cols  : pool address  (str)
    vals  : sqrtPriceX96  (stored as string)

Usage:
    poetry run python src/zora-coin/plot_prices.py
"""
from pathlib import Path
import math

import pandas as pd
from decimal import Decimal
import plotly.express as px

SLOT0_CACHE = Path("slot0_timeseries.parquet")
OUT_DIR = Path("plots")
CHUNK_DIR = Path("slot0_chunks")
OUT_DIR.mkdir(exist_ok=True)

Q96 = 1 << 96
LN_1P0001 = math.log(1.0001)

def sqrt_price_x96_to_price(sp_x96: int) -> float:
    """Convert sqrtPriceX96 (Q64.96) to price."""
    return (sp_x96 / Q96) ** 2

def sqrt_price_x96_to_tick(sp_x96: int) -> int:
    """Convert sqrtPriceX96 to the nearest Uniswap v3 tick."""
    price = sqrt_price_x96_to_price(sp_x96)
    # floor to nearest integer tick
    return int(math.log(price) / LN_1P0001)

def main():
    if not CHUNK_DIR.exists():
        raise FileNotFoundError(
            f"{CHUNK_DIR} not found. Run swap_data.py first to build slot0 chunks."
        )

    # Aggregate all chunked parquet files
    chunk_files = sorted(CHUNK_DIR.glob("slot0_*.parquet"))
    if not chunk_files:
        raise FileNotFoundError(f"No parquet files in {CHUNK_DIR}")

    df = pd.concat([pd.read_parquet(f) for f in chunk_files])
    # drop duplicated block rows that may appear if rerun
    df = df[~df.index.duplicated(keep="last")].sort_index()

    # Convert string/scientific‑notation values → big Python ints
    def to_big_int(val):
        if pd.isna(val):
            return pd.NA
        try:
            return int(val)
        except Exception:
            # fall back to Decimal for scientific‑notation strings
            return int(Decimal(str(val)))
    df = df.apply(lambda col: col.map(to_big_int, na_action='ignore'))

    # Melt to long format for easier filtering & plotting
    long_df = (
        df.reset_index()
        .melt(id_vars="block_number", var_name="pool", value_name="sqrtPriceX96")
        .dropna(subset=["sqrtPriceX96"])
    )

    # Compute tick and price
    long_df["price"] = long_df["sqrtPriceX96"].apply(sqrt_price_x96_to_price)
    long_df["tick"] = long_df["sqrtPriceX96"].apply(sqrt_price_x96_to_tick)

    # --- interactive Plotly line chart ---
    fig = px.line(
        long_df,
        x="block_number",
        y="price",
        color="pool",
        title="Uniswap v3 pools – price vs. block",
        labels={
            "block_number": "Block number",
            "price": "Price (token1 / token0)",
            "pool": "Pool",
        },
        template="plotly_white",
    )

    out_path = OUT_DIR / "all_pools_price.html"
    fig.write_html(out_path, include_plotlyjs="cdn")
    print(
        f"Wrote interactive HTML plot to {out_path} with "
        f"{len(long_df['pool'].unique())} pools."
    )

if __name__ == "__main__":
    main()